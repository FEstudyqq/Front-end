## 1. 타입스크립트의 장점

### 정적 타입 검사 ⇒ 타입 에러 방지

JS는 컴파일 단계가 아니라 런타임에서 변수의 타입이 결정되는 **`동적 타입 언어`** 이다. 따라서 변수를 실제 타입에 맞지 않게 사용하는 경우를 사전에 방지하기가 어렵다. 예를 들어 `number` 타입인 변수를 함수처럼 호출하도록 코드를 짜도, 실행하기 전에는 이 코드가 오류를 야기하는지 알 수 없다.

반면 TS는 컴파일 단계에서 타입을 결정하는 **`정적 타입 언어`** 이다. 런타임에서의 에러를 방지하므로 **안정성**이 높고, 런타임에서 할 일이 줄어들기 때문에 그만큼 **실행 속도가 빠르다**. 또한 타입이 명시되어 있으므로 **코드를 읽을 때 역할과 동작을 유추하기 쉽다**.

### 타입 추론(자동으로 타입을 적용해줌)

```tsx
let foo = 123;
foo = '456'; // Error: cannot assign `string` to `number`
```

타입을 지정하지 않아도, 타입시스템이 타입을 추론하여 암시적으로 적용한다. 이러한 타입 추론을 잘 활용하면, **타입 명시를 생략하여 코드를 간결하게 유지**할 수 있다.

또 위 코드 예제처럼 컴파일 오류가 있더라도, 최대한 JS 코드를 반환한다.

---

### 동적 타입 언어

- 장점
  - 유연한 코드 작성
  - 타입 생략을 통한 높은 생산성
- 단점
  - 타입 에러를 미리 방지하지 못함

### 정적 타입 언어

- 장점
  - 타입 명시를 통한 높은 안정성
  - 사전 타입 명시를 통한 런타임 실행속도 향상
- 단점
  - 타입을 일일이 명시해야 하는 번거로움
  - 규모가 클수록 타입 선언이 차지하는 코드가 많아져 복잡함
  - 타입을 관리하는 어려움

## 2. type/interface 차이

### type alias (타입 별칭)

- 타입 집합을 특정 "별칭"에 할당할 수 있음
  ```tsx
  type User = { age: number };
  type Age = number;
  ```
- 에디터에서 마우스를 호버하면 타입 리터럴이 띄워짐
- 인터페이스와 달리, 중복 선언 불가능

### interface (인터페이스)

- 타입 정의를 객체 꼴로만 할 수 있음
  ```tsx
  interface Item { price : number };
  interface Price: number; // 이런 식으로 쓸 순 없음!
  ```
- 에디터에서 마우스를 호버하면 인터페이스가 띄워짐
- Declaration Merging: 동일한 이름의 인터페이스끼리 병합되는 기능 ⇒ 확장성⬆️ 안정성⬇️

  ```tsx
  interface Item {
    price: number;
  }

  // 똑같은 이름으로 선언 가능
  interface Item {
    name: string;
  }

  // Property 'name' is missing in type '{ price: number; }' but required in type 'Item'.
  const item: Item = {
    price: 18000,
  };
  ```

---

참고: [`type`과 `interface` 중 고민할 때 도움이 되었던 영상](https://youtu.be/Idf0zh9f3qQ?si=w4MpyU9MPv4S_0aR)

## 3. enum/object 차이

### Enums

- 이름이 있는 상수들의 집합을 정의할 때 사용
- 마우스 호버 시 enum이 띄워짐
- 예제

  - 숫자 열거형

    ```tsx
    enum Week {
      MON = 1,
      TUE, // 2
      WED, // 3
      THU,
      FRI,
      SAT,
      SUN, // 7
    }

    let day: Week;
    day = Week.MON; // assign value
    day = 1; // same as Week.MON
    day = 'Hello'; // Error: Type '"Hello"' is not assignable to type 'Week'.
    let weekend: Week.SAT | Week.SUN; // possible to use enum member as type
    ```

    - 만약 초깃값이 없으면 `0`부터 시작함

  - 문자열 열거형
    ```tsx
    enum Direction {
      Up = 'UP',
      Down = 'DOWN',
      Left = 'LEFT',
      Right = 'RIGHT',
    }
    ```
  - 열거형 멤버를 숫자, 문자열뿐만 아니라 계산(ex. 함수호출)의 결과 등으로 초기화 가능
  - 한 enum 안에 다양한 타입의 멤버가 있을 수 있음

### Object

- 객체 타입으로, 객체를 구성하는 각 프로퍼티의 타입을 나타낼 수 있음
- 마우스 호버 시 객체 리터럴이 띄워짐
- `Object`로 `Enum`을 대체 가능
- `Enum` 사용 시 발생 가능한 성능 문제를 `Object`로 대체하여 해결 가능 (참고: [TypeScript enum을 사용하지 않는 게 좋은 이유를 Tree-shaking 관점에서 소개합니다.](https://engineering.linecorp.com/ko/blog/typescript-enum-tree-shaking))

## 4. JS의 `any`와 TS의 `unknown`의 차이

- `any`
  - 아무 타입이든 될 수 있는 타입
  - 뭐든 될 수 있기에, 다른 타입인 변수에 할당하려 해도 **타입 에러가 나지 않음**
  - 타입을 안 쓰면 타입스크립트를 쓰는 의미가 없기 때문에 꼭 필요할 때가 아니면 지양
- `unknown`

  - 어떤 타입인지 모른다는 걸 나타내는 타입 (즉 타입이 불확실한 타입)
  - 어떤 타입인지 모르기 때문에, 특정 타입인 변수에 할당하거나, 특정 타입처럼 연산하려 하면 **타입 에러가 발생함**
  - ⇒ 이 점에서 `any`의 safe 버전, 대체 타입이라고 여겨짐
  - 타입 좁히기/타입 단언을 통해 구체적인 타입으로 정한 후 사용하도록 유도할 수 있음

  ```tsx
  let variable: unknown;

  let var1: string = variable; // Type 'unknown' is not assignable to type 'string'.
  let var2: number = variable; // Type 'unknown' is not assignable to type 'number'.

  variable - 1; // 'variable' is of type 'unknown'.
  variable.property; // 'variable' is of type 'unknown'.

  variable = [1, 2, 3]; // 배열 값을 할당해도, 배열처럼 연산하려 시도하면 에러 발생
  variable[0]; // 'variable' is of type 'unknown'.

  const asserted = variable as number[]; // 타입 단언
  asserted[0];
  ```

## 5. `never` 타입에 대해 알고 있나요?

- 코드가 논리적으로 발생할 수 없는 경우를 나타내는 타입
- 주로 리턴 값을 절대 내보내지 않는 함수의 리턴 타입으로 사용함
- `never` 타입 변수에는 `never`가 아닌 타입을 할당할 수 없음
  - 이 특성을 이용하여 코드 안정성을 높일 수 있음
  - `never` 타입에는 할당할 수 없으므로, 유니온 타입에서 자동으로 제거됨

```tsx
// NeverIsRemoved = string | number
type NeverIsRemoved = string | never | number;

// neverReturns: () => never
const neverReturns = () => {
  throw new Error('Always throws, never returns');
};
```

```tsx
// never 타입에 never만 할당 가능함을 이용해,
// switch문의 완전함(모든 경우가 다뤄짐)을 보장할 수 있음
enum Flower {
  Rose,
  Rhododendron,
  Daisy,
}

const flowerLatinName = (flower: Flower) => {
  switch (flower) {
    case Flower.Rose:
      return 'Rosa rubiginosa';
    case Flower.Rhododendron:
      return 'Rhododendron ferrugineum';
    case Flower.Daisy:
      return 'Bellis perennis';

    default:
      // Flower 타입에 새로운 꽃 요소를 추가한다면,
      // never의 특성에 의해 아래 라인에서 에러가 발생함
      const _exhaustiveCheck: never = flower; // never 타입에는 never만 할당 가능
      return _exhaustiveCheck;
  }
};
```

## 6. 배열과 튜플의 차이

- `Array`
  - 배열을 나타내는 타입
  - 원소로 포함 가능한 타입이 지정되어 있어도, 순서와 길이가 보장되지 않음
- `Tuple`

  - 각 인덱스에 대한 타입이 지정되어, **순서와 길이가 보장되는** 배열

  ```tsx
  // 배열
  type strOrNum = (string | number)[];
  const arr: strOrNum = [0, 0, '0', 0]; // 타입 순서 상관 X, 길이 보장 X

  // 튜플
  type CustomResponse = [string, number]; // 0번에 string, 1번에 number 고정
  const response: CustomResponse = ['{}', 200];
  response[2]; // Tuple type 'CustomResponse' of length '2' has no element at index '2'.
  ```

  ```tsx
  // 시작 타입은 알지만 길이를 알 수 없을 때 spread로 튜플 사용 가능
  type Student = [string, ...number[]];
  const students: Student[] = [
    ['Kim', 90, 20, 40],
    ['Lee', 80],
  ];
  ```

## 7. 제네릭과 제네릭의 유틸리티 타입

### Generics

- 선언 시점이 아닌 생성 시점에 타입을 명시할 수 있게 해주는 기능
- 제네릭 타입으로 선언하면, **하나의 선언 코드로 다양한 타입을 사용 가능** ⇒ **재사용성** ⬆️
- 꺽쇠(`<>`) 안에 타입을 명시 & 타입명은 관용적으로 `T`, `K`, `D` 등을 사용
- **`any`와 비교** | | any | 제네릭 | | --- | --- | --- | | 타입 수용성 | 모든 타입을 감싸는 하나의 타입 | 어떤 타입으로든 변할 수 있는(메타몽같은) 타입 매개변수 | | 타입 보장성 | 특정 타입에 대해서만 쓰여도, 해당 타입임을 보장할 수 없음 | 바인딩된 타입의 정보를 유지하여, 항상 해당 타입임을 보장함 |

  ```tsx
  function echoAny(arg: any) {
    return arg;
  }

  function echoGen<T>(arg: T) {
    return arg;
  }

  const resultAny = echoAny('message'); // const resultAny: any
  const resultGen = echoGen('message'); // const resultGen: "message"
  ```

### [유틸리티 타입](https://www.typescriptlang.org/ko/docs/handbook/utility-types.html)

- `Partial<Type>`: `Type`의 모든 프로퍼티를 **선택적**으로 하는 타입 (=부분집합)
- `Required<Type>`: `Type`의 모든 프로퍼티를 **필수**로 하는 타입
- `ReadOnly<Type>`: `Type`의 모든 프로퍼티를 **읽기 전용**으로 하는 타입
- `Record<Keys, Type>`: 키(`Key`)-밸류(`Type`)로 맵핑하는 타입
- `Pick<Type, Keys>`: `Type`에서 특정 `Key`를 선택한 타입
- `Omit<Type, Keys>`: `Type`에서 특정 `Key`를 제거한 타입
- `Exclude<Type, ExcludedUnion>`: `Type`에서 특정 타입 집합을 제거한 타입 (=차집합)
  - `Omit`은 `키`를 선택해 제거하는 반면, `Exclude`는 타입 집합을 제거함
- `Extract<Type, Union>`: `Type`에서 특정 타입 집합에 속하는 타입만 추출한 타입 (=교집합)
- `NonNullable<Type>`: `Type`에서 `null`, `undefined`를 제거한 타입

## 8. 유니온 타입과 인터섹션 타입에 대해 각각 한 문장으로 설명해주세요.

- 유니온 타입
  - 타입 집합 간 합집합
  - 타입과 타입 사이에 `|`로 나타냄
  ```tsx
  type OddNumber = 1 | 3 | 5 | 7 | 9;
  type WindowStates = 'open' | 'closed' | 'minimized' | string;
  // WindowsStates의 타입은 유니온 타입이 아닌 string 타입임
  ```
- 인터섹션 타입
  - 타입 집합 간 교집합
  - 타입과 타입 사이에 `&`로 나타냄

## 9. '타입 좁히기'를 예시를 들어 설명해주세요.

- 타입 좁히기/넓히기
  - 타입이 나타낼 수 있는 `가능성`을 줄이거나 확장하는 것
  - 다른 타입일 가능성을 제거하거나 `typeof`, `instanceof`, `in` 등의 타입 가드를 통해 타입을 좁힐 수 있음
  - 타입을 좁혀 특정 타입임을 보장할 수 있음
  ```tsx
  const neverChange = 'Hi'; // const neverChange: 'Hi'
  let canBeChange = 'Hi'; // let canBeChange: string

  type Person = {
    name: string;
    age: number;
  };

  function func(arg: string | Date | Person | undefined) {
    // arg.length // error occurs

    if (arg === undefined) return;
    // now, it is ensured that arg is not undefined

    if (typeof arg === 'string') arg.length; // type is string in here
    else if (arg instanceof Date) arg.getDay();
    else if ('age' in arg) arg.name; // 'key' in 'variable'
  }
  ```

## 10. namespace
