## 1. 브라우저의 렌더링 과정

### 주요 렌더링 과정 (Critical Rendering Path)

1. **`IP 주소` 획득**
   1. `DNS`를 통해 도메인 네임(ex. `www.naver.com`)과 매칭되는 `IP 주소`를 얻음
   2. 이 때 여러 `DNS`에게 물어물어 얻음 (`root DNS`에게 `www.naver.com`을 물어보고, 얘가 알려준 다른 `.com 담당 DNS`한테 갔다가 `naver 담당 DNS`에 갔다가 뭐 이런 식)
   3. 이렇게 얻은 `IP 주소`는 캐싱해서 씀
2. **`IP 주소`에 리소스 요청**
3. **리소스 파싱하여 `DOM`, `CSSOM` 생성** (바이트→문자→토큰→노드→객체모델)

   1. 파일을 **바이트**코드 형태로 받음 (ex. `3C 62 6F 79 64 6C 6C`)
   2. 바이트를 **문자**로 인코딩 (ex. `<span>Hi</span>`)
   3. 문자를 **토큰**화 (ex. `startTag: span`, `Hi`, `endTag: span`)
   4. 토큰에 의미를 부여하여 객체 **Node**로써 구조화 (ex. `{ tag: span, attribute: … }`)
   5. 문서의 Node(Object) 간 관계(Model)를 그린 **Object Model** 트리 구조 생성 ⇒ `DOM`, `CSSOM`

   ```
   💡 Parser가 문서를 읽다가 스타일 시트에 관한 `link` 태그를 발견하면, 즉시 해당 리소스, 즉 CSS 파일을 요청한다. `CSSOM`은 위와 동일한 과정을 거쳐 형성되며, `DOM` 파싱을 중단하지 않는다.
   `script` 태그를 발견하면 리소스를 요청하고 스크립트 파일을 받아와 실행한다. 실행하는 동안 `DOM` 파싱이 중단된다.
   ```

   - 참고: [async, defer 속성에 대해 설명해주세요](./1.%20HTML.md#11-async-defer속성에-대해-설명해주세요)

   ```
   💡 `DOM`, `CSSOM`이 모두 완성되어야 다음 단계로 넘어가므로, `CSSOM` 생성 속도가 웹사이트 성능의 중요한 역할을 한다. 스타일 시트에 관한 `link` 태그를 `script` 태그처럼 바디 섹션 맨 아래에 둘 수 없는 이유이기도 하다.
   ```

4. **`렌더 트리` 생성**
   - `DOM`, `CSSOM`을 결합해서 만든 최종 렌더링 설계도
   - 페이지 렌더링에 필요한 노드만 포함함 (ex. `display: none` 요소, `meta` 태그 등 제외)
5. **렌더링**
   1. `Layout`: 각 객체의 정확한 위치와 크기(pixel)를 계산하는 단계
   2. `Paint`: 그리기 호출 목록을 만들고, 레이어를 나누어 실제로 픽셀을 채우는 단계
   3. `Composite`: 레이어를 하나로 합성하는 단계

### Reflow vs. Repaint

|  | Reflow | Repaint |
| --- | --- | --- |
| 개념 | Layout → Paint → Composite 단계가 실행되는 것 | Paint → Composite 단계가 실행되는 것 |
| 실행 상황 | - 최초 렌더링 시<br>- 윈도우 리사이징 시 (viewport 크기 변경 시)<br>- 노드 추가/제거 시<br>- 요소 위치/크기 변경 시<br>- 폰트/이미지 크기 변경 시<br> | - 요소의 위치/크기가 아닌 외관 변경 시<br>(ex. `background-image`, `color`, `box-shadow`) |

## 2. BOM(Browser Object Model)이란?

- **개념**
  - 문서(Document) 외의 모든 것을 제어하기 위해 브라우저가 제공하는 객체들을 구조화한 것
  - 최상위 객체는 `window`
  - 표준이 없음

## 3. SPA, MPA, CSR, SSR의 차이

### 페이지 구성 방식: SPA vs. MPA

|  | SPA | MPA |
| --- | --- | --- |
| 뜻 | SinglePageApplication | MultiplePageApplication |
| 개념 | 하나의 페이지(html)로 앱을 구성 | 여러 페이지(html)로 앱을 구성 |
| 특징 | - 화면 깜빡임 등이 없어 UX가 우수 | - 화면 깜빡임이 생김<br>- 라우팅할 때마다 서버에게 HTML을 요청함 |

### 렌더링 방식: CSR vs. SSR

|  | CSR | SSR |
| --- | --- | --- |
| 뜻 | ClientSideRendering | ServerSideRendering |
| 개념 | 클라이언트(브라우저) 측에서 렌더링 수행 | 서버 측에서 렌더링 수행 |
| 렌더링 과정 | 1. 서버에 웹사이트 요청<br>2. 서버로부터 빈 html과 js 파일을 받음<br>3. 렌더링 과정 수행 (동적으로 DOM 생성) | 1. 서버에 웹사이트 요청<br>2. 서버가 데이터, CSS가 적용된 html을 만듦<br>3. 서버로부터 html을 받음 ⇒ `TTV`<br>4. 화면에 html 띄움 ⇒ `TTI` |
| 장점 | - 상호작용이 빠름 (렌더링이 필요한 부분만 요청하여 변경하니까)<br>- 서버 부하가 덜 함<br>- `TTV(Time-to-View)`, `TTI(Time-to-Interaction)`이 동일 | - 첫 화면 로딩 속도가 빠름 (즉각 렌더링 가능하니까)<br>- SEO에 유리 (서버에서 html을 완성해서 주니까) |
| 단점 | - 첫 화면 로딩 속도가 느림 (모든 파일을 한 번에 받고, 다 처리해야 화면에 뜨니까)<br>- SEO에 약함 (검색엔진 봇이 서치한 시점은 js가 실행되어 metadata가 생기기 전. 즉 html이 빈 껍데기니까) | - 상호작용이 느림 (상호작용할 때마다 서버에 요청하고 페이지를 렌더링해야 하니까)<br>- 서버 부하가 있음<br>- `TTV(Time-to-View)`, `TTI(Time-to-Interaction)`이 동일하지 않음 |

```
💡 SSG(Static Site Generation, Static Rendering)는 SSR처럼 서버가 HTML을 만들어준다는 점에서 비슷하지만, SSR은 요청 즉시(동적으로) HTML을 만들고, SSG는 미리 다 만들어놓고(정적으로) 요청 시 응답한다는 점에서 다르다.
```

## 4. CORS 정의 및 목적

### **SOP(Same Origin Policy, 동일 출처 정책)**

- 출처가 동일해야 리소스를 공유할 수 있도록 하는 웹 보안 정책

### **출처(Origin)란?**

- `프로토콜, 호스트, 포트`가 같으면 두 URL은 동일한 출처를 가짐
- ex) URL: http://store.company.com/dir/page.html
    - 출처: http://store.company.com
    - 프로토콜: http
    - 호스트: store.company.com
    - 포트: 80 (http: 80, https: 443이 기본)

### **CORS(Cross-Origin Resource Sharing, 교차 출처 리소스 공유)**

- **정의 및 목적**
    - 출처가 다른 서버 간 리소스 공유를 허용하는 **HTTP 요청 매커니즘**
    - SOP를 우회하여 다른 출처의 리소스에 안전하게 접근하게 해줌
    - 동일 출처 간에도 특정 조건에 따라 CORS 오류가 발생할 수 있음!
        - http/https 혼합, 자격 증명(쿠키, 인증 헤더 등)을 포함한 요청 등
- **허용 방법**
    - 서버에 요청 시, 요청 헤더의 **`Origin` 필드에 자신의 출처를 포함**
    - 서버는 응답 시, 응답 헤더의 **`Access-Control-Allow-Origin` 필드에 허용할 출처를 포함**
    - 요청을 보내는 출처가 서버에서 허용한 출처 목록에 포함되어 있다면 리소스 접근 가능
- **에러 해결 방법**
    - 응답 헤더 설정
        - 서버가 클라이언트의 출처를 응답 헤더 `Access-Control-Allow-Origin` 필드에 포함
    - 프록시 서버 사용
        - 요청을 클라이언트 → 프록시 서버 → 원본 서버
    - WebSocket 사용
        - CORS는 HTTP 요청에 적용되는 매커니즘이므로, WebSocket을 사용해 우회 가능

## 5. 웹 접근성을 높이기 위한 방법은 어떤 것들이 있을까요?

- **웹 접근성이란?**
  - 장애인, 고령자 등이 웹사이트에서 제공하는 정보를 비장애인과 동등하게 접근하고 이용할 수 있도록 보장하는 것
  - 여기서 장애인이란, 일반적으로 생각하는 장애뿐만 아니라, 웹에 접근하는 데 영향을 주는 일시적인 장애 상태(ex. 팔이 부러진 사람)와 환경적 제약(ex. 밝은 햇빛)을 포괄함
- **웹 접근성을 높이는 방법**
  - 콘텐츠의 의미, 용도를 나타내는 텍스트를 제공한다 (ex. 레이블, 대체 텍스트, 제목)
  - 미디어 콘텐츠에는 **대체 텍스트**를 제공한다
  - 마크업의 **오타, 오류를 방지**한다
  - 의미가 있는 이미지를 배경 이미지(background-image)로 제공하지 않는다
  - **콘텐츠 내용은 색상에 의존하지 않는다** (ex. 그래프, 차트, 필수 입력 사항 등)
  - 소리가 있는 콘텐츠에 **자막/수화/원고**을 제공한다
  - 소리가 있는 콘텐츠는 **자동 재생을 금지하고**, 사용자가 의도했을 때 재생되게 한다
  - 모든 기능은 **키보드만으로 조작**이 가능해야 한다 (마우스 커서 궤적이 중요한 콘텐츠 제외)
  - 사용자 입력과 버튼 등의 조작은 충분한 크기로 서로 여백을 두고 제공한다
  - 시간 제한이 있는 콘텐츠가 있다면, 사전에 알리고, **시간 연장 수단을 제공**한다
- 참고
  - [주니어 디자이너가 꼭 알아야 할 '웹 접근성'](https://yozm.wishket.com/magazine/detail/1942/)
  - [네이버 널리](https://nuli.navercorp.com/)

## 6. 검색 엔진 최적화(Search Engine Optimization, SEO)에 대해 알고 있나요?

```
💡 검색 엔진 최적화(SEO)는 검색 엔진이 자료를 수집하는 방식에 맞게 웹 페이지를 구성하는 것을 말합니다. 검색 엔진 최적화를 통해 사용자가 원하는 콘텐츠를 쉽게 찾을 수 있게 하고, 웹 페이지가 검색 결과 상위에 나올 가능성을 높일 수 있습니다.
```

- **개념**
  - 검색 엔진이 자료를 수집하고 순위를 매기는 방식에 맞게 웹 페이지를 구성하는 것
- **목적**
  - 사용자(+검색 엔진)가 원하는 콘텐츠를 쉽게 찾을 수 있도록 함
  - 웹 페이지가 검색 결과의 상위에 나올 가능성을 높이기 위함
- **최적화 방법**
  - 유의미한 URL 사용
    - good: `https://www.example.com/pets/cats`
    - bad: `https://www.example.com/2/6772756D`
  - 유용한 콘텐츠 제공
    - 시맨틱 태그 사용
    - 탐색에 도움이 되는 텍스트 제공 (ex. 대체 텍스트, 캡션 등)
    - 고유한 콘텐츠 (다른 사람이 이미 게시하지 않은)
    - 최신 콘텐츠
    - \*신뢰 가능한 콘텐츠
  ```
  💡 구글 검색 엔진 봇은 출처 링크가 포함되어 있으면 신뢰 가능한 콘텐츠로 판단하지만, 네이버는 오히려 스팸으로 간주한다.
  ```
  ```
  💡 검색엔진 봇이 모든 `meta` 태그를 유의미하다고 인식하는 것은 아니다.
  ```

## 7. 이벤트

### 이벤트 바인딩

- 어떤 요소의 이벤트에 이벤트 핸들러 함수를 연결하는 것
- 바인딩 방법

  - 1️⃣인라인 이벤트 핸들러

    ```html
    <div onclick="handleClick()"></div>

    <script>
      function handleClick() {
        console.log(this); // window
        console.log(event.currentTarget); // <div onclick='handleClick()'></div>
      }
    </script>
    ```

    - `html`과 `javascript`의 관심사가 분리되지 않는 문제
    - 이벤트 핸들러 내부 `this`가 `window`를 가리킴 ⇒ 의도하지 않은 문제가 발생할 수 있음
    - 🚨더이상 쓰이지 않음!

  - 2️⃣이벤트 핸들러 프로퍼티

    ```html
    <div></div>

    <script>
      const div = querySelector('div');
      div.onclick = function handleClickA() {}; // 무시됨
      div.onclick = function handleClickB() {}; // 덮어씀
    </script>
    ```

    - 마지막에 등록한 프로퍼티가 기존 값을 덮어씀
    - 크로스 브라우저 호환성이 높음 (IE 8만큼 옛날 브라우저에서도 지원됨)

  - 3️⃣`addEventListener()` 메서드

    ```html
    <div></div>

    <script>
      const div = querySelector('div');
      div.addEventListener('click', handleClickA);
      div.addEventListener('click', handleClickB);

      div.removeEventListener('click', handleClickB);
    </script>
    ```

    - 깉은 타입에 대한 여러 리스너를 하나의 요소에 등록할 수 있음
    - `removeEventListener()`를 이용해 연결된 이벤트 리스너를 해제할 수 있음

### 이벤트 전파: 캡처링 vs. 버블링

같은 이벤트 타입의 두 이벤트 핸들러가 한 요소에 작동했을 때 일어나는 메커니즘

- **캡처링**: `최상위 요소`부터 `실제로 선택된 요소`까지, 발생한 이벤트에 대한 핸들러가 동작
- **버블링**: `실제로 선택된 요소`부터 `최상위 요소`까지, 발생한 이벤트에 대한 핸들러가 동작
- **이벤트 전파 막기**: `event.stopPropagation()`을 이용해 이벤트 전파를 막을 수 있음

```
💡 버블링과 캡처링 이벤트가 동시에 존재하는 경우, 캡처링이 먼저 실행되고 그 후 버블링이 실행된다.
```

```
💡 거의 모든 이벤트는 버블링 되지만, `focus` 이벤트와 같이 버블링되지 않는 이벤트도 있다.
캡처링을 강제로 발생시키려면 `addEventListener`의 `capture` 옵션을 `true`로 설정해야 한다.
```

```html
<div>
  <button>
    <span>Click Me!</span>
  </button>
</div>

<script>
  const div = document.querySelector('div');
  const btn = document.querySelector('button');

  div.addEventListener('click', (e) => alert('div 캡처링'), true); //-----(a)
  div.addEventListener('click', (e) => alert('div 버블링')); //-----------(b)
  btn.addEventListener('click', (e) => alert('button 캡처링'), true); //--(c)
  btn.addEventListener('click', (e) => alert('button 버블링')); //--------(d)
</script>
```

예를 들어 위 코드에서 `<button>` 클릭 시, 이벤트 캡처링이 먼저 일어나고, 그 다음 버블링이 일어나, (a) → (c) → (d) → (b) 순서로 실행된다. 등록된 이벤트가 없는 `<span>`을 클릭해도 마찬가지이다.

### `event.target` vs. `event.currentTarget`

- `event.target`: 이벤트가 시작되게끔 트리거 역할을 한 요소
- `event.currentTarget`: 이벤트 핸들러가 할당된, 실질적으로 이벤트를 발생시킨 요소(=이벤트 핸들러 내의 `this`)

### 이벤트 위임 (Event Delegation)

- 여러 개의 자식 요소에 동일한 구조의 이벤트 핸들러를 할당하고 싶을 때, 모든 자식 요소에 이벤트 핸들러를 할당하지 않는 대신 **부모 요소에 이벤트 핸들러를 할당**하고 **`event.target`으로 자식 요소를 컨트롤**하는 방법
- 이벤트 위임은 이벤트 버블링에 의한 이벤트 전파를 이용한 디자인 패턴임

## 8. 쿠키/세션/토큰

### 등장 배경

- HTTP의 특징 ([프로토콜 (HTTP/HTTPS)](https://www.notion.so/HTTP-HTTPS-e7653e56b32e48fd9c7080e75230aa88?pvs=21))
    - 비연결성(connectionelss): 클라이언트가 서버의 응답을 받으면 TCP/IP 연결이 종료됨
    - 무상태성(stateless): 서버가 클라이언트의 이전 상태를 보존하지 않음
- 따라서 서버가 클라이언트의 정보를 유지하지 못함
    - 페이지 이동마다 로그인 정보, 사용자 입력 정보 등이 초기화됨
- 해결 방법으로, `쿠키/세션/토큰`으로 클라이언트 측 정보를 저장하고 이를 요청에 포함함

|  | **쿠키** | **세션** | **토큰** |
| --- | --- | --- | --- |
| **저장 위치** | 클라이언트(브라우저) | 서버 | 클라이언트(주로 웹스토리지) |
| **만료 시점** | - 지속쿠키: 만료 시간 경과<br/>- 세션쿠키: 브라우저 종료 | - 세션 타임아웃<br/>- 만료 시간 경과<br/>- 브라우저 종료 | 설정 가능 |
| **보안** | 낮음 | 높음 | 높음 (토큰 암호화, 검증 등 절차) |
| **서버 부하** | X | O | X |

### 쿠키

- **개념**
    - 서버가 클라이언트에 보내는 작은 데이터 조각
    - 브라우저에 저장했다가, 동일한 서버에 요청을 보낼 때 헤더에 자동으로 포함됨
    - 서버가 두 요청이 동일한 브라우저에서 들어왔는지 판단하기 위해 사용
    - 이름/만료일/도메인 등 속성을 포함함
- **특징**
    - 1️⃣낮은 보안
        - 브라우저에서 JS로 쿠키 생성/접근 가능 ⇒ XSS에 취약
        - 쿠키에 민감 정보 포함 시 위험
    - 2️⃣요청 오버헤드
        - 매 요청마다 쿠키를 포함해야 함
        - 쿠키가 많을수록 요청 메시지 크기가 커짐
    - 3️⃣개수 제한
    - 4️⃣브라우저 간 비공유
        - 브라우저마다 쿠키 지원 형태가 달라 브라우저 간 공유가 불가능
- **용도**
    - 개인화 (ex. 팝업 보지 않기, 사용자 선호, 테마 등의 세팅)
    - 트래킹 (ex. 사용자 행동을 기록하고 분석하는 용도)
- **쿠키 관련 HTTP 헤더 필드 및 속성**
    - 서버 응답 시 `Set-Cookie` 필드로 쿠키 생성
        - `Secure` 속성: HTTPS 요청에 대해서만 쿠키를 전송함
        - `HttpOnly` 속성: 브라우저에서 JS로 `document.coockie`에 접근할 수 없게 함
        
        ```
        HTTP/1.0 200 OK
        Content-type: text/html
        Set-Cookie: yummy_cookie=choco
        Set-Cookie: tasty_cookie=strawberry; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
        
        [page content]
        ```
        
    - 클라이언트 요청 시 브라우저가 자동으로 `Cookie` 필드에 쿠키 포함하여 전송
        - 쿠키에 여러 속성이 있어도, `Cookie`에는 쿠키 이름-값만 포함함
        
        ```
        GET /sample_page.html HTTP/1.1
        Host: www.example.org
        Cookie: yummy_cookie=choco; tasty_cookie=strawberry
        ```
        
- **만료 시점에 따른 종류**
    - 지속 쿠키: 만료 기간(`Expires`, `Max-Age` 속성)을 명시해, 그동안 저장됨
    - 세션 쿠키: 만료 기간을 명시하지 않아, 세션이 유효한 동안 저장됨 (프로세스 종료 시 삭제)

### 세션

- **개념**
    - 서버에 클라이언트 상태를 관리하는 시스템
    - 서버에서 클라이언트 별 상태를 추적할 수 있음
    - 종료 시점
        - 세션 타임아웃 (사용자가 일정 시간 활동하지 않는 경우)
        - 세션 혹은 세션 쿠키 만료 기간 경과
        - 사용자 로그아웃, 브라우저 종료 등
    - 세션 저장소: 메모리, 파일 시스템, 데이터베이스 등
- **동작 과정**
    - 최초 요청 시, 서버는 세션 생성
    - ⇒ 서버 응답 시, 세션 ID 발급해 쿠키로 전달 (세션 쿠키)
    - ⇒ 후속 요청 시, 세션 ID를 포함
    - ⇒ 브라우저 종료 or 만료 시, 세션과 세션 ID 삭제
- **특징**
    - 1️⃣높은 보안
        - 서버에서 상태를 관리함
        - 쿠키가 노출돼도 세션 ID에는 민감 정보가 없음
        - but 세션 ID 탈취해 클라이언트로 위장 가능
    - 2️⃣서버 부하
        - 사용자(세션)가 많을수록 부하가 커짐
- **용도**
    - 세션 관리: (ex. 로그인 상태 유지, 장바구니)

## 9. 성능
