## 1. 프로토콜 - HTTP

**프로토콜**

서로 다른 시스템이나 기기간 데이터 교환을 원활하게 하기 위한 표준화 된 통신 규약

[**HTTP/HTTPS(Hyper Text Transfer Protocol SSL)**](https://velog.io/@reggias/%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91HTTP-HTTPS)

- HTTP : 웹에서 데이터를 주고 받기 위한 프로토콜
- HTTPS : HTTP에 SSL 프로토콜을 추가해 데이터를 암호화 하는 프로토콜

[**HTTP 버전별 특징**](https://zu-techlog.tistory.com/113)

- HTTP 1.0 : 하나의 연결당 하나의 요청 처리
- HTTP 1.1 : keep-alive 옵션을 추가해 하나의 연결당 여러번의 송수신 가능
- HTTP 2 : 여러 리소스를 한번에 요청 가능
- HTTP 3 : UDP 기반의 프로토콜로 사용

**HTTP Status Code**

클라이언트가 보낸 특정 HTTP 요청에 대한 서버의 응답 코드 상태 코드에 따라 요청의 성공이나 실패 여부 판단

- **1xx(정보제공) :** 클라이언트의 요청을 받았으며 프로세스를 계속 진행함
- **2xx(성공) :** 클라이언트가 요청한 동작을 수신/이해/승낙하여 성공적으로 처리함
  - 200 : 요청을 성공적으로 처리함
  - 201 : 요청이 처리되어서 새로운 리소스 생성
  - 202 : 요청은 접수했지만, 처리가 완료되지 않음
- **3xx(리다이렉션) :** 클라이언트는 요청 완료를 위해 추가 작업을 해야함
  - 301 : 지정할 리소스가 새로운 URI로 이동함
  - 303 : 다른 위치로 요청
  - 307 : 임시 리다이렉션 필요
- **4xx(클라이언트 에러) :** 클라이언트 요청에 오류가 있음
  - 400 : 요청 구문 에러
  - 401 : 지정한 리소스에 대한 액세스 권한 X
  - 403 : 지정한 리소스에 대한 엑세스 금지
  - 404 : 지정한 리소스를 찾을 수 없음
- **5xx(서버 에러) :** 클라이언트의 요청은 유효하나 서버가 처리 실패함
  - 500 : 서버 내부 에러 발생
  - 501 : 요청한 URI의 메소드에 대해 서버가 구현하고 있지 않음
  - 502 : 게이트웨이 또는 프록시 역할을 하는 서버가 그 뒷단의 서버로부터 잘못된 응답을 받았다.

**HTTP 헤더 / HTTTP 페이로드**

- 헤더(Header) : HTTP 요청이나 응답에 대한 메타 데이터
- 페이로드(Payload) : 실제 데이터

<br/ >

## 2. RESTful API

**API(Application Programming Interface )**

응용 프로그램에서 데이터를 주고 받기 위한 인터페이스로 어떠한 사이트에서 데이터를 공유할 경우 어떤 방식으로 정보를 요청해야 되는지, 어떠한 형태로 데이터를 제공받게 되는지에 대한 규격

**REST(Representational State Transfer)**

자원을 이름으로 구분하여 자원의 상태(정보)를 주고 받는 것

**REST의 구성요소**

- **자원(RESOURCE)** : HTTP URI
- **행위(Verb)** : HTTP METHOD
  - **GET** : 조회
  - **POST** : 리소스 생성
  - **PUT** : 리소스 전체 교체
  - **PATCH** : 리소스의 일부 수정
  - **DELETE** : 리소스 삭제
- **표현(Representations)** : HTTP Message Pay Load

**REST API(Representational State Transfer)**

- REST 아키텍쳐를 따르는 API

**RESTful API 설계 가이드**

1. URI 는 정보의 자원을 표현해야 한다.
2. 자원에 대한 행위는 HTTP Method로 표현한다.

<br />

## 3. 프록시(Proxy)란?

**프록시/프록시서버**

서버와 클라이언트 사이에서 대리로 통신을 수행해 주는 것으로 중계 역할을 해주는 서버를 프록시 서버라고 한다.

**포워드 프록시**

- 클라이언트의 요청을 받아 서버에 전달해주는 프록시
- 캐싱된 데이터가 존재한다면 중간에서 빠르게 클라이언트에게 응답 해줌

**리버스 프록시**

- 클라이언트에게 받은 요청을 보고 알맞은 서버에게 요청을 처리하고록 데이터를 넘겨주는 프록시

<br />

## 4. DNS

**IP 주소**

네트워크 상에서 인터넷에 연결된 컴퓨터들이서로를 인식하기 위해 지정받은 식별용 번호

**도메인(Domain)**

IP 주소를 식별하는 문자열

**DNS(Domain Name Server)**

도메인과 IP 주소를 한 쌍으로 저장하고 있는 서버

**URI/URL/URN**

![alt text](/img/image.png)

- URI : 인터넷 자원을 식별할 수 있는 문자열
- URL : 리소스를 어떻게 얻을것이고 어디에서 가져와야 하는지 명시하는 URI
- URN : 리소스 경로

[**주소창에 URL을 검색했을 때 일어나는 일?**](https://github.com/FEDeepDive/Front-end/blob/devkyoung2/9.%20WebBrowser.md)

1. 사용자가 브라우저에 URL(www.naver.com)을 입력한다.
2. 입력한 URL 주소 중, 도메인 이름에 해당하는 naver.com가 캐싱 되어있나 확인

   1-1. 도메인 이름에 맞는 IP 주소가 존재하면 바로 IP 주소를 반환

   1-2. 도메인 이름에 맞는 IP 주소가 존재하지 않는다면 DNS 서버에 IP 주소 요청

3. 브라우저가 서버와 TCP 연결을 진행
4. 전달받은 IP 주소를 이용해 웹 브라우저는 웹 서버에게 해당 웹 사이트에 맞는 HTML 문서 요청(HTTP 프로토콜 사용)

   2-1. 이때, 웹서버는 정적인 데이터를 클라이언트로 바로 돌려줄 수 있으나, 동적인 데이터는 was로 요청함
